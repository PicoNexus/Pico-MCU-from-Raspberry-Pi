Add custom labels up to five characters for keys M1-M24, S1-S24, T1-T24. 

line 86
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 0   KeySkip 1  CheckSerial 0  KeyHeldEnable  1           BLOnOff 1    Rotate180 0              KeyFontBold 0      ResetOnceEnable 0
// 7     nKeys 1       nChar  n      nKeysPage  8  nKeysCharSet[10] c         CRLF 0                    crlf1 0x0D             crlf2 0x0A
// 23    iList 0       MuteOn 0           VolOn 1  LayerAxD 0 Media 0       XFiles 0               Brightness 0           
// 30   BsDNum 0       RetNum 8         LayerAD 0     KeyFontColour 0   SaveLayout 2                 OptionOS 0            KeyRepeat 6 
// 37  NormVal 0       DimVal 3         nKeys34 1          nDir[20] c        nDirZ always=0  nKeysLnkChar[10] 10               nDirX 0,1,2,3
// 72   MLabel 0       SLabel 0          TLabel 0
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Currently last entry TLabel = Config1[74]; Can use strcpy((char *)&Config1[40], nDir); and inverse, to access as char string array nDirZ=0=EOS 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
cSt byte Config1Size = 80;       //   0   1   2   3   4   5   6   7  8  9  10  11  12  13  14  15  16  17  18  19 20 21   22   23 24 25 26 27 28 29  30  31 
byte Config1[Config1Size]          = {1,  0,  1,  1,  0,  0,  0,  1,'n',8,'n','o','p','q','r','s','t','m','a','k',0, 0x0D,0x0A,0, 1, 0, 0, 0, 0, 0,  0,  8, 
                                      0,  0,  2,  0,  6,  0,  3,  1,'/',0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0,   0,   0, 0, 0, 0, 0, 0,'n','o','p',
                                     'q','u','v','w','x','y','z', 0, 0, 0, 0,  0,  0,  0,  0,  0  };
cSt byte Config1Reset[Config1Size] = {1,0,1,1,0,0,0,1,'n',8,'n','o','p','q','r','s','t','m','a','k',0,0x0D,0x0A,0, 1, 0, 0, 0, 0, 0,  0,  8, 
                                      0,0,2,0,6,0,3,1,'/',0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,0,   0,   0, 0, 0, 0, 0, 0,'n','o','p',
                                     'q','u','v','w','x','y','z', 0, 0, 0, 0,  0,  0,  0,  0,  0  };                                    
bool WriteConfig1Change = false; // Do save if true
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 


line 269
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// if MLabel SLabel TLabel > 0 use 5-char max labels in files MLabel SLabel TLabel instead of M,S,T 1 - M,S,T 24
// 
char keyLabel[12][6] = {""};               //  5 characters max n0000 - n9999

// Custom Label up to five characters for 24 M,S,T keys used if MLabel 1 SLabel 1 TLabel 1
// Then read contents of the filename in file LabelM,S,T into LabelArrM,S,T 
// Need fast access to this - cannot read from SDCard every time
char LabelArr[3][24][6];      // Size 144*3=432 LabelArr[0] M LabelArr[1] S LabelArr[2] T custom keys
bool MLabel, SLabel, TLabel;  // if>0 then custom labels for 24 M,S.T keys
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

line 390
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CmKey = false;                 // Check if *codes are from pressing [*Cm] key or entered directly
const static int StarCodesMax = 88; // StarCodes Count 16+16+16+16+16+8 StarNum = 0-87
const static char StarCode[StarCodesMax][5] =    
{ "*am*", "*as*", "*at*", "*bb*", "*bl*", "*br*", "*ca*", "*cm*", "*cr*", "*ct*", "*cx*", "*db*", "*de*", "*df*", "*e0*", "*e1*", 
  "*e2*", "*e3*", "*e4*", "*fa*", "*fc*", "*fm*", "*fo*", "*fs*", "*ft*", "*im*", "*is*", "*it*", "*ix*", "*kb*", "*ke*", "*kr*", 
  "*ks*", "*ld*", "*lf*", "*lm*", "*ls*", "*lt*", "*m1*", "*m2*", "*mt*", "*mT*", "*nt*", "*nT*", "*os*", "*ot*", "*oT*", "*po*", 
  "*r0*", "*r1*", "*r2*", "*r3*", "*rn*", "*ro*", "*rt*", "*rT*", "*sa*", "*sd*", "*se*", "*sm*", "*ss*", "*st*", "*ta*", "*tb*", 
  "*tp*", "*tt*", "*tw*", "*ua*", "*ul*", "*up*", "*x0*", "*x1*", "*x2*", "*x3*", "*x4*", "*x5*", "*x6*", "*x7*", "*x8*", "*x9*", 
  "*0R*", "*09*", "*0d*", "*0n*", "*0p*", "*0s*", "*0t*", "*0x*"  };

const static byte StarCodeType[StarCodesMax] =    
{ 1,      1,      1,      2,      36,     5,      6,      7,      50,     8,      51,     3,      9,      17,     10,     10,     
  10,     10,     10,     11,     12,     11,     13,     11,     11,     44,     44,     44,     44,     14,     39,     38,     
  15,     16,     42,     55,     55,     55,     18,     19,     20,     20,     21,     21,     22,     23,     23,     25,     
  37,     26,     40,     41,     49,     27,     24,     24,     28,     29,     30,     28,     28,     28,     31,     4,      
  31,     31,     31,     33,     32,     43,     35,     35,     35,     35,     35,     35,     35,     35,     35,     35,     
  34,     45,     53,     46,     47,     48,     54,     52      };


line 900
///////////////////////////////////////////////////////////////////////////////////////////////
void DoMSTLabel(byte Option, byte mst)  // Pointer to LabelArrM,S.T [24][6] Size 192
///////////////////////////////////////////////////////////////////////////////////////////////
{ char LabelFile[7] = "LabelM";
  char MST[] = "0MCST";
  int a, b, n, m;
  File f1, f2;
  // char LabelArr[24][6];  // Size 192

  a = Layout-1-(Layout>2); // a = 0,1,2 for M,S,T Layouts
  b = mst-1-(mst>2);       // b = 0,1,2 for M,S,T Layouts
  Serial.println(); Serial.print(a); Serial.print(" "); Serial.println(b);
  
  if (Option==0)
    { LabelFile[5] = MST[mst];             // 73 + (Layout==3)*6 + (Layout==4)*7;   // Layout = 1-4 LayerAD = 0-3
      f1 = SDFS.open(LabelFile, "r");
      n = f1.size();
      Serial.println(n);
      Serial.println(LabelFile);
      f1.readBytes(NameStr1, n); f1.close(); // NameStr1 is the filename that holds the 24 (5 char max), new label names
      Serial.println(NameStr1);

     f2 = SDFS.open(NameStr1, "r");  n = f2.size(); 
     Serial.println(n); 
     // f2.readBytes(inputString, n); for (n=0; n<24; n++) for (m=0; m<6; m++) LabelArr[n][m] = inputString[n*6+m]; 
     f2.readBytes((char *)LabelArr[b], n);  f2.close();
     Serial.println(LabelArr[b][0]);
     Serial.println(LabelArr[b][1]);
    }      

  if (Option==1) { if (a==0 && !MLabel) return; if (a==1 && !SLabel) return; if (a==2 && !TLabel) return;
                   for (n=4; n<7; n++)  strcpy(keyLabel[n], LabelArr[a][n-4+LayerAD*6]);    // 0+0,1+0.2+0 0+6
                   for (n=8; n<11; n++) strcpy(keyLabel[n], LabelArr[a][n-5+LayerAD*6]); }  // 3+0,4+0,5+0 3+6  
  
}


line 935
///////////////////////////////////////////////////////////////////////////////////////
// Check and save new SDCard file strings SDFilename is in sdcard.h select with *sd*n
// These are limited size Bytesize = 200 - sensible here because wait until written
// Directly written to SDCard files with PC only limited by SDCard capacity
///////////////////////////////////////////////////////////////////////////////////////
void DoNewSDCard()
{ int n = 0;
  byte *BytePtr;
  bool Found = false, Label = false;
  byte a, b, d, c = 0;
  int ASize;
  char LabelFile[18] = "LabelM";  
  
  Found = NewData = StrOK = ByteOK = false;  

  a = RecBytes[0];      // * char  
  b = RecBytes[3];      // Also * if Starcode 
  if (a==0x2A&&b==0x2A) { for (n=0; n<=NumBytes; n++) KeyBrdByte[n] = RecBytes[n]; 
                          KeyBrdByteNum = NumBytes; if (SendBytesStarCodes()) { ConfigButtons(1); return; }  } // <*xy*nn> sent
                          
  a = a - 48;                          // ASCII Number 0-9 subtract 48
  Label = (a==61 || a==67 || a==68);   // a = m,s,t is labelfile name which points to another file with new labels for 24 M,S,T keys;
  Found = (a<10);                      // a = 1 to 6 - only 6 Keys on every Layer A-D

  if (Label) { Serial.println(a);
               Serial.println(RecBytes[0]);
               LabelFile[5] = RecBytes[0] - 32;                                      // +48-32 = M, S, T
               BytePtr = MacroBuff; 
               for (n=1; n<=NumBytes; n++) { BytePtr[n-1] = RecBytes[n]; } // Skip 1 = char <m,<s,<t < is removed earlier
               Serial.println(LabelFile);
               Serial.println(NumBytes);
               Serial.println(MacroBuff[0]);
               Serial.println(MacroBuff[1]);
               File f = SDFS.open(LabelFile, "w");                         // Filename LabelM,S,T
                    f.write(BytePtr, NumBytes-1);                          // Write filename to SDCard
                    f.print('\0');                                         // Add NULL to end of filename in File LabelX    
                    f.close();  
                    strcat(LabelFile, " saved"); status(LabelFile); return; }
  
  if (Found){ if (a>0) c = a + (LayerAD)*6 - 1;    // S1-S6=>S19-S24 T1-T6=>T19=T24 M1-M6=>M19=M24 -> 1-24 used  
                                                   // c = 0 to 23 for every Layout M S T c=1+0x6-1=0 c=6+3x6-1=23
                                                   
              if (Layout!=2) {if (a>0) {ByteOK = true;  BytePtr = MacroBuff;           // No need for 24 SDC1to24[c]
                                        status((char *)SDName[c]); }  }                // SDCard file 1-21 x 1-24
                  
              for (n=1; n<=NumBytes; n++) { BytePtr[n-1] = RecBytes[n]; }  }           // Skip 1,2 = char <#               
    
   if ((Found)&&(ByteOK))   { File f = SDFS.open(SDName[c], "w");  // Filename set with *sd*1-9,(13-19), k,K,M,S,T
                              f.write(BytePtr, NumBytes);          // (13-19=A-G must be directly copied to SDCard
                              //f.print('\0');                     // 4-9=U-Z can be written here    
                              f.close();    }                                        
}


line 2403
  for (n=0; n<12; n++) strcpy(keyLabel[n], Labels[LayerAD][b][n]); // label = 3 chars max except nKeys 5 chars   
  for (n=0; n<12; n++) keyColor[n] = Colours[b][n];

  if (Layout!=2 && MLabel+SLabel+TLabel>0) DoMSTLabel(1, Layout);


line 2688
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ReadConfig1()
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{ int n;
  File f1 = LittleFS.open("Config1", "r");
  int FSz = f1.size(); // Check for valid Config1
  if (FSz!=Config1Size) { for (int n=0; n<Config1Size; n++) Config1[n] = Config1Reset[n]; WriteConfig1(0); return; }
  f1.read(Config1, Config1Size); 
  f1.close();
  
  KeySkip = Config1[0];
  CheckSerial = Config1[1];
  KeyHeldEnable = Config1[2];
  BLOnOff = Config1[3];   
  Rotate180 = Config1[4];                                    // Must check if rotate=0 but calibrate-data is for rotate=180  
  KeyFontBold = Config1[5];                                  // Use: if (calData[4]==5 && Rotate180==1) Rotate180=0;  
  ResetOnceEnable = Config1[6];                              //  or: if (calData[4]==3 && Rotate180==0) Rotate180=1;     
  nKeys = Config1[7];                                        // 
  nChar = Config1[8];     if (nChar<0x30) nChar = 'n';       // Old Config1 with nChar=0x00 then nKeys label = blank 
  nKeysPage = Config1[9]; if (nKeysPage<1) nKeysPage = 8;    // Old Config1 with nKeysPage=0 not valid 
  for (n=1; n<11; n++) nKeysCharSet[n-1] = Config1[9+n];     // if (nKeysCharSet[0]<0x30) reset all 10 to default
  CRLF =  Config1[20];                                       // CR LF Filter
  crlf1 = Config1[21]; 
  crlf2 = Config1[22];
  if (crlf1==0 && crlf2==0) { crlf1 = 0x0D; crlf2 = 0x0A; }  // Reset to default if both NULL character filters
  iList =    Config1[23]; 
  MuteOn =   Config1[24]; 
  VolOn =    Config1[25];
  LayerAxD = Config1[26]; 
  Media =    Config1[27]; 
  XFiles =   Config1[28];
  Brightness = Config1[29];
  BsDNum =   Config1[30];  // 0 = DeleteBackspace  
  RetNum =   Config1[31];  // 8 = ReturnKey
  LayerAD =  Config1[32];  
  KeyFontColour = Config1[33]; if (KeyFontColour) KeyFont = Black; else KeyFont = White;  // Button Font Bold/Normal labels
  SaveLayout =    Config1[34]; 
  OptionOS =      Config1[35]; 
  KeyRepeat =     Config1[36]; if (KeyRepeat<2) KeyRepeat=6; RepTimePeriod = KeyRepeat*100;  // Unusable Macropad if too short
  NormVal =       Config1[37]; 
  DimVal =        Config1[38];
  nKeys34 =       Config1[39];
  strcpy(nDir, (char *)&Config1[40]); // 40-59 60=nDirZ=0 
  for (n=1; n<11; n++) nKeysLnkChar[n-1] = Config1[60+n];    // 61-70 Config1[61-70] 
  nDirX =         Config1[71];
  MLabel = Config1[72];  SLabel = Config1[73]; TLabel = Config1[74];  
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void WriteConfig1(bool Option)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{ int n;
  if (Option==1) {Config1[0] = KeySkip;
                  Config1[1] = CheckSerial;
                  Config1[2] = KeyHeldEnable;
                  Config1[3] = BLOnOff;
                  Config1[4] = Rotate180;
                  Config1[5] = KeyFontBold;
                  Config1[6] = ResetOnceEnable;
                  Config1[7] = nKeys;
                  Config1[8] = nChar;
                  Config1[9] = nKeysPage; 
                  for (n=1; n<11; n++) Config1[9+n] = nKeysCharSet[n-1];
                  Config1[20] = CRLF; 
                  Config1[21] = crlf1; 
                  Config1[22] = crlf2;  
                  Config1[23] = iList;   // iList 0,1
                  Config1[24] = MuteOn; 
                  Config1[25] = VolOn;
                  Config1[26] = LayerAxD;                  
                  Config1[27] = Media; 
                  Config1[28] = XFiles;
                  Config1[29] = Brightness;
                  Config1[30] = BsDNum;  // 0 = DeleteKey  
                  Config1[31] = RetNum;  // 8 = ReturnKey
                  Config1[32] = LayerAD; // LayerADLetter (A-D) = LayerAD (0-3) + 65 -> 0-3 => A-D
                  Config1[33] = KeyFontColour; 
                  Config1[34] = SaveLayout; 
                  Config1[35] = OptionOS;   
                  Config1[36] = KeyRepeat;
                  Config1[37] = NormVal; 
                  Config1[38] = DimVal; 
                  Config1[39] = nKeys34;                  
                  strcpy((char *)&Config1[40], nDir); // 40-59 60=nDirZ=0                    
                  for (n=1; n<11; n++) Config1[60+n] = nKeysLnkChar[n-1];   // Config1[61-70] 
                  nDirX       = Config1[71];
                  Config1[72] = MLabel; Config1[73] = SLabel; Config1[74] = TLabel;    
                }
  
  File f1 = LittleFS.open("Config1", "w"); 
  if (Option==2) f1.write(Config1Reset, Config1Size);   // Reset all to default - could be Rotate180 problem
            else f1.write(Config1,      Config1Size);   // Write current Config1 values if Option = 0 or 1
  f1.close();  
}

line 2783
///////////////////////////////////////////////////////////////
void InitCfg(bool Option)    // Only 1 on cold start or reboot
///////////////////////////////////////////////////////////////
{ char *ChrPtr;
  char NameStr[] = { "0123456789" };
  byte b, *BPtr;
  int ASize =0, m = 0, n = 0;
  uint16_t ByteLen = 0;
  
  // WriteConfig1(0); delay(10); // Use only once then comment out when there are changes to Config1 structure or size
  
  if (Option) {
      
      if (LittleFS.exists("Config1"))           ReadConfig1();          else WriteConfig1(2);           // Read Config1 else write default values
     
      if (LittleFS.exists("SDCardArr"))         ReadSDCardArr();
      if (LittleFS.exists("MouseCfg"))          ReadMouse();
      if (LittleFS.exists("MediaCfg"))          ReadMediaConfig();
      if (LittleFS.exists("iList"))             ReadInstructionList();                                  // iList -> MacroInstructionList
      if (LittleFS.exists("DoCal"))             DoCal    = true;        else DoCal           = false;   // 1 -> Run calibration on start
      if (LittleFS.exists("MacroUL"))           MacroUL  = true; SwitchMacroUL(0);                      // Upper/Lower case filenames
      if (LittleFS.exists("x1x6"))              Readx1x6();                                             // always read if exists
      if (LittleFS.exists("Bank123File"))       ReadBank123();                                          // always read if exists
  }    
  
  for (n=0; n<24; n++) {DoMSTName(n, 3); BPtr = Str1to12[n]; MacroS1S12[n] = 4;                   // DoFileBytes read eof LayerAxD 0 FlashMem 1 SDCard
                        MacroSizeS1S12[n] = DoFileBytes(0, MSTName, BPtr, ByteSize, LayerAxD); }  // 0 = read 1 = write
           
  for (n=0; n<24; n++) {DoMSTName(n, 4);  BPtr = Ttr1to12[n]; MacroT1T12[n] = 4;                  // DoFileBytes read eof LayerAxD 0 FlashMem 1 SDCard   
                        MacroSizeT1T12[n] = DoFileBytes(0, MSTName, BPtr, ByteSize, LayerAxD); }
           
  for (n=0; n<24; n++) {DoMSTName(n, 1);  BPtr = Mtr1to12[n]; MacroM1M12[n] = 4;                  // DoFileBytes read eof LayerAxD 0 FlashMem 1 SDCard         
                        MacroSizeM1M12[n] = DoFileBytes(0, MSTName, BPtr, ByteSize, LayerAxD); } 
  
  if (LittleFS.exists("inputStr"))   { ChrPtr = inputString; DoFileStrings(StrOK, "inputStr", ChrPtr, 0); }
  if (LittleFS.exists("TimersData")) ReadTimers(1); else ReadTimers(2); // If not exist create TimersData with default data

  if (MLabel) DoMSTLabel(0, 1); if (SLabel) DoMSTLabel(0, 3); if (TLabel) DoMSTLabel(0, 4);

  ReadBSDKeyKArr();    // New defines for K1-K24 in BSD1-3
}


line 3592
         case 55: ////////////////////// KeyBrdByte[1]==0x6c&&KeyBrdByte[2]==0x6D,0x73,0x74 *lm* *ls* *lt* + optional filename that contains 24 keylabels
       { // Keylabels On/Off + optional filename that contains 24 keylabels for example *lt*label1 -> LabelT now has content label1 
         // If one char added after *lm,s,t* such as *lm,s,t*x then file FileM,S,T reset with default text label1,2,3
         strcpy(NameStr3, " OFF"); strcpy(NameStr1, "labelx"); strcpy(NameStr2, "LabelX"); // label1,2,3 is default text in files LabelM,S,T 
         if (k2==0x6D) { Config1[72] = MLabel = !MLabel; NameStr2[5] = 'M'; NameStr1[5] = '1'; if (MLabel) strcpy(NameStr3, " ON"); m = 1; }
         if (k2==0x73) { Config1[73] = SLabel = !SLabel; NameStr2[5] = 'S'; NameStr1[5] = '2'; if (SLabel) strcpy(NameStr3, " ON"); m = 3; }
         if (k2==0x74) { Config1[74] = TLabel = !TLabel; NameStr2[5] = 'T'; NameStr1[5] = '3'; if (TLabel) strcpy(NameStr3, " ON"); m = 4; }
         if (knum>4)   { if (knum>5) for (n=0; n<knum-4; n++) NameStr1[n] = KeyBrdByte[4+n];   // default is NameStr1 = label1,2,3
                         File f1 = SDFS.open(NameStr2, "w"); f1.print(NameStr1); f1.print('\0'); f1.close();  }         
         DoMSTLabel(0, m); WriteConfig1(0); strcat(NameStr2, NameStr3); status(NameStr2); StarOk = true; break; }
      } return StarOk; 

line 4475
////////////////////////
void showKeyData() 
////////////////////////
{  byte p, n, m, b;
   char c; 
   File f1, f2, f3;
   
   SerPr2;
   Serial.print("Labels M: " );
   if (MLabel) Serial.print("On  Target: "); else Serial.print("Off Target: ");
   f1 = SDFS.open("LabelM", "r"); n = f1.size(); f1.readBytes(NameStr1, n); f1.close(); Serial.print(NameStr1);
   SerPr2;
   Serial.print("Labels S: " );
   if (SLabel) Serial.print("On  Target: "); else Serial.print("Off Target: ");
   f2 = SDFS.open("LabelS", "r"); n = f2.size(); f2.readBytes(NameStr2, n); f2.close(); Serial.print(NameStr2);
   SerPr2;
   Serial.print("Labels T: " );
   if (TLabel) Serial.print("On  Target: "); else Serial.print("Off Target: ");
   f3 = SDFS.open("LabelT", "r"); n = f3.size(); f3.readBytes(NameStr3, n); f3.close(); Serial.print(NameStr3);
   SerPr2;

